#!/usr/bin/python
#
# Molecular dynamics simulation plotter
#
# Copyright (C) 2008  Peter Colberg
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import tables
import Gnuplot
import glob
import os, os.path, sys
import subprocess
import tempfile
import time


"""
Plot thermodynamic equilibrium properties
"""
def plot_equilibrium_properties(root, basename):
    # time resolution
    timestep = root._v_attrs.timestep

    def spawn_gnuplot(title):
        # one gnuplot instance per plot to allow multiple *interactive* windows
        g = Gnuplot.Gnuplot()

        # With the current gnuplot release (4.2.3), the persist option for the
        # wxt terminal is buggy and causes CPU usage to rise to 100% after the
        # main gnuplot process exits. This bug is fixed in gnuplot 4.3 CVS
        # since 2007-04-29.
        g('set terminal wxt persist enhanced title "ljfluid: %s"' % title)

        g('set xlabel "t*"')
        return g

    plot = 'plot "%s" binary array=inf format="%%double" using ($0*%f):%s notitle with lines'

    g = spawn_gnuplot('Mean potential energy per particle')
    g('set ylabel "E_{pot}^*(t^*)"')
    f = file(basename + '_epot.bin', 'wb')
    f.write(root.EKIN.read().tostring())
    f.close()
    g(plot % (f.name, timestep, '1'))

    g = spawn_gnuplot('Mean kinetic energy per particle')
    g('set ylabel "E_{kin}^*(t^*)"')
    f = file(basename + '_ekin.bin', 'wb')
    f.write(root.EPOT.read().tostring())
    f.close()
    g(plot % (f.name, timestep, '1'))

    g = spawn_gnuplot('Mean total energy per particle')
    g('set ylabel "E^*(t^*)"')
    f = file(basename + '_etot.bin', 'wb')
    f.write(root.ETOT.read().tostring())
    f.close()
    g(plot % (f.name, timestep, '1'))

    g = spawn_gnuplot('Temperature')
    g('set ylabel "T^*(t^*)"')
    f = file(basename + '_temp.bin', 'wb')
    f.write(root.TEMP.read().tostring())
    f.close()
    g(plot % (f.name, timestep, '1'))

    g = spawn_gnuplot('Pressure')
    g('set ylabel "P^*(t^*)"')
    f = file(basename + '_press.bin', 'wb')
    f.write(root.PRESS.read().tostring())
    f.close()
    g(plot % (f.name, timestep, '1'))

    g = spawn_gnuplot('Velocity center of mass')
    g('set ylabel "|<v^*(t^*)>|"')
    f = file(basename + '_vcm.bin', 'wb')
    f.write(root.VCM.read().tostring())
    f.close()
    g(plot % (f.name, timestep, '(sqrt($1*$1+$2*$2))'))


"""
Plot correlations
"""
def plot_correlations(root, basename):
    def spawn_gnuplot(title):
        # one gnuplot instance per plot to allow multiple *interactive* windows
        g = Gnuplot.Gnuplot()

        # With the current gnuplot release (4.2.3), the persist option for the
        # wxt terminal is buggy and causes CPU usage to rise to 100% after the
        # main gnuplot process exits. This bug is fixed in gnuplot 4.3 CVS
        # since 2007-04-29.
        g('set terminal wxt persist enhanced title "ljfluid: %s"' % title)

        g('set xrange [%f:]' % root._v_attrs.timestep)
        g('set logscale x')
        g('set format x "10^{%T}"')
        g('set xlabel "dt^*"')
        return g

    plot = 'plot "%s" binary array=inf format="%%double%%double%%*double" using 1:%s notitle with lines lt 1'
    replot = 'replot "%s" binary array=inf format="%%double%%double%%double" using 1:%s:%s title "%s" with yerrorbars lt 1'

    def time_ordered_write(f, dataset):
        data = {}
        for nblock in range(len(dataset)):
            for sample in dataset[nblock]:
                data[(sample[0], nblock)] = sample.tostring()

        # sort dataset after time interval
        for k in sorted(data.keys()):
            f.write(data[k])

    # write mean squared displacement data file
    f = file(basename + '_msd.bin', 'wb')
    time_ordered_write(f, root.MSD)
    f.close()

    g = spawn_gnuplot('Mean squared displacement')
    g('set key left top Left reverse')
    g('set logscale y')
    g('set format y "10^{%T}"')
    g(plot % (f.name, '2'))
    g(replot % (f.name, '2', '3', '<(r^*(t^*+dt^*) - r^*(t^*))^2>_N'))

    g = spawn_gnuplot('Diffusion constant')
    g('set key left top Left reverse')
    g('unset logscale y')
    g('set format y')
    g(plot % (f.name, '($2/$1)'))
    g(replot % (f.name, '($2/$1)', '($3/$1)', '<(r^*(t^*+dt^*) - r^*(t^*))^2>_N / dt^*'))

    # write mean quartic displacement data file
    f = file(basename + '_mqd.bin', 'wb')
    time_ordered_write(f, root.MQD)
    f.close()

    g = spawn_gnuplot('Mean quartic displacement')
    g('set key left top Left reverse')
    g('set logscale y')
    g('set format y "10^{%T}"')
    g(plot % (f.name, '2'))
    g(replot % (f.name, '2', '3', '<(r^*(t^*+dt^*) - r^*(t^*))^4>_N'))

    # write velocity autocorrelation data file
    f = file(basename + '_vac.bin', 'wb')
    time_ordered_write(f, root.VAC)
    f.close()

    g = spawn_gnuplot('Velocity autocorrelation')
    g('set key right top Right noreverse')
    g('set logscale y')
    g('set format y "10^{%T}"')
    g(plot % (f.name, '2'))
    g(replot % (f.name, '2', '3', '<(v^*(t^*+dt^*) * v^*(t^*))>_N'))


"""
Plot trajectory
"""
def plot_trajectory(root, basename):
    # remove stray gnuplot output files
    for fn in glob.glob(basename + '_*.png'):
        os.unlink(fn)

    # font requires Debian package ttf-dejavu-core
    if not 'GDFONTPATH' in os.environ:
        os.environ['GDFONTPATH'] = '/usr/share/fonts/truetype/ttf-dejavu'

    g = Gnuplot.Gnuplot()

    output = 'set output "%s"'
    # FIXME use fraction of cutoff length as particle radius
    plot = 'plot "%s" binary array=inf format="%%double%%double" using 1:2 notitle with points pt 7 ps 2'

    g('set terminal png font "DejaVuSans,12" enhanced size 1080, 1080')
    g('unset key')
    g('unset title')
    g('set x2tics')
    g('set y2tics')
    # FIXME set xrange, yrange according to box length

    # time resolution
    timestep = root._v_attrs.timestep

    data_file = None
    frame_fn = basename + '_%06d.png'
    sys.stdout.write('gnuplot: %6sf' % '')
    for i in range(len(root.trajectory)):
        # write trajectory sample to temporary binary file
        f = tempfile.NamedTemporaryFile('wb')
        f.write(root.trajectory[i].tostring())
        f.flush()
        # plot trajectory sample
        g(output % (frame_fn % i))
        g('set label 1 front "t^* = %g" font "DejaVuSans,14" at graph 0.85, 0.05' % (i * timestep))
        g(plot % (f.name))

        # FIXME better way to wait for file creation (maybe pyinotify?)
        while not os.path.exists(frame_fn % i):
            time.sleep(1e-2)

        # erase previously printed frame number characters
        sys.stdout.write('\010 \010' * 7)
        sys.stdout.write('%6df' % (i + 1))
        sys.stdout.flush()

        # erase previous data file
        data_file = f

    # wait for gnuplot to finish
    del g
    # remove temporary files
    del data_file

    sys.stdout.write('\n')
    sys.stdout.flush()

    # render movie with ffmpeg2theora
    ffmpeg = subprocess.Popen(['ffmpeg2theora', frame_fn, '-x', '720', '-y', '720', '-S', '0', '-o', '%s.ogg' % basename, '--nosound'], close_fds=True)
    errno = ffmpeg.wait()

    # remove gnuplot output files
    for fn in glob.glob(basename + '_*.png'):
        os.unlink(fn)

    if errno:
        raise Exception('mencoder exited with error code %d' % errno)


"""
Molecular dynamics simulation plotter
"""
def main(args):
    if len(args) < 1:
        print >> sys.stderr, 'Usage: %s [file]' % os.path.basename(sys.argv[0])
        sys.exit(1)

    # open HDF5 data file
    try:
        h5file = tables.openFile(args[0], mode='r')
    except IOError:
        print >> sys.stderr, "%s: ERROR: could not read file: %s" % (os.path.basename(sys.argv[0]), args[0])
        sys.exit(1)

    # detect data format
    basename = os.path.splitext(args[0])[0]
    if 'EKIN' in h5file.root:
        # thermodynamic equilibrium properties file
        plot_equilibrium_properties(h5file.root, basename)

    elif 'MSD' in h5file.root:
        # correlations file
        plot_correlations(h5file.root, basename)

    elif 'trajectory' in h5file.root:
        # trajectory dump file
        plot_trajectory(h5file.root, basename)

    else:
        print >> sys.stderr, "%s: ERROR: HDF5 file contains unknown data" % (os.path.basename(sys.argv[0]))
        h5file.close()
        sys.exit(1)

    # close HDF5 data file
    h5file.close()


if __name__ == '__main__':
    main(sys.argv[1:])

