Implementation
**************

MD simulation
=============

Inheritance hierarchy
---------------------

The following is a simple diagram of the class hierarchy representing the MD
simulation core. Classes which represent a backend are filled.

.. graphviz::

   digraph hierarchy_of_D {
       rankdir="BT"

       node [shape=rect,color="#86989B",fontname=Helvetica,fontsize=12]

       base	[ label="mdsim_base<…>" ]
       ljfluid_base [ label="ljfluid_base<…>" ]
       ljfluid_gpu_base [ label="ljfluid_gpu_base<…>" ]

       subgraph backends {
	   node [style=filled,fillcolor="#AFC1C4",fontcolor=white];
	   ljfluid_gpu_square [ label="ljfluid<ljfluid_impl_gpu_square, …>" ]
	   ljfluid_gpu_neighbour [ label="ljfluid<ljfluid_impl_gpu_neighbour, …>" ]
	   ljfluid_host [ label="ljfluid<ljfluid_impl_host, …>" ]
       }

       ljfluid_base -> base
       ljfluid_gpu_base -> ljfluid_base
       ljfluid_gpu_square -> ljfluid_gpu_base
       ljfluid_gpu_neighbour -> ljfluid_gpu_base
       ljfluid_host -> ljfluid_base

       { rank=same; ljfluid_gpu_base ljfluid_host }
   }


Classes summary
---------------

A short description of the basic functionality of each class template.

.. glossary::

   mdsim_base<…>
      This class implements the common basis of a hard- or soft-sphere simulation.
      It contains the size of the system (number of particles), the mixture type
      (monodisperse or bidisperse) and the density and rectangular box length.
      It holds the performance accumulators for measuring the average times
      of individual functions or GPU kernels comprising the MD algorithm.

      The function ``state``, which is used upon restoring the system state
      from a trajectory sample and checks for matching particle number, wraps
      coordinates to periodic boundary conditions and optionally rescales the
      density or box size to a new value.

   ljfluid_base<…>
      This class implements extends its base class to Lennard-Jones systems,
      or soft-sphere simulations employing a discrete integration of the
      equations of motion, and contains common functionality of host and GPU
      backends. It contains the potential cutoff radii, the timestep, collision
      diameters, potential smoothing parameters, thermostat temperature and
      frequency, and the simulation time-step.

   ljfluid_gpu_base<…>
      This class implements the common functionality of the GPU backends.
      It holds the CUDA streams and events used for ordering and profiling CUDA
      kernel launches. It contains common reduction kernels to compute the
      potential energy sum, virial equation sum, center of mass velocity and
      squared velocity sum. It contains a particle sorting kernel for sorting
      integers in GPU memory by their respective tags.

      Notable functions include the ``lattice`` to generate an fcc lattice in
      GPU memory, ``random_permute`` to randomly assign particle types in a
      binary mixture, ``init_tags`` to initialise particle numbers,
      ``rescale_velocities`` to scale velocities to a desired temperature,
      ``boltzmann`` to assign Maxwell-Boltzmann distributed velocities, and
      ``update_forces`` to wrap the mdstep GPU kernel.

   ljfluid<ljfluid_impl_gpu_square, …>
      This class implements the gpu_square backend.

   ljfluid<ljfluid_impl_gpu_neighbour, …>
      This class implements the gpu_neighbour backend.

   ljfluid<ljfluid_impl_host, …>
      This class implements the host backend.

Modular design principles
=========================

HALMD consists of various module groups (avoiding the word 'class' here) which are initialised and interact with each other depending on the configuration at runtime. A module group should satisfy the following criteria:

* It is a natural entity for storing a particular set of data and/or providing algorithms.
* It functions independently, but may access data and algorithms of other module groups.
* It may introduce a unique (and independent?) set of programme options.
* Two module groups should not be easily combinable??? (separability)

A module group is realised by a set of module classes which derive from a base class. These classes reflect implementations for different architectures (host, GPU) or different algorithms (force laws, integrators).

Modules in namespace halmd
--------------------------

.. glossary::

    :doc:`core <impl/core>`
        Refined by `mdsim::core`

        Description:

Modules in namespace halmd::mdsim
---------------------------------

.. glossary::

    :doc:`force <impl/mdsim_force>`
        Refined by `mdsim::host::forces::lj`

        Description:

    :doc:`position <impl/mdsim_position>`
        Refined by `mdsim::host::position::file`, `mdsim::host::position::lattice`

        Description:

    :doc:`sort <impl/mdsim_sort>`
        Refined by `mdsim::host::sort::hilbert`

        Description:

    :doc:`velocity <impl/mdsim_velocity>`
        Refined by `mdsim::host::velocity::file`, `mdsim::host::velocity::boltzmann`

        Description:

    :doc:`box <impl/mdsim_box>`
        Refined by `mdsim::host::box`

        Description:

    :doc:`thermodynamics <impl/mdsim_thermodynamics>`
        Refined by `mdsim::host::thermodynamics`

        Description:

    :doc:`random <impl/mdsim_random>`
        Refined by `mdsim::host::random`

        Description:

    :doc:`integrator <impl/mdsim_integrator>`
        Refined by `mdsim::host::integrator::verlet`

        Description:

    :doc:`particle <impl/mdsim_particle>`
        Refined by `mdsim::host::particle`, `mdsim::gpu::particle`

        Description:

    :doc:`neighbor <impl/mdsim_neighbor>`
        Refined by `mdsim::host::neighbor`

        Description:

Modules in namespace halmd::mdsim::*
-------------------------------------

(These modules have no base in halmd::mdsim?)

* :doc:`mdsim::samples::host::trajectory <impl/mdsim_samples_host_trajectory>`
* :doc:`mdsim::samples::gpu::trajectory <impl/mdsim_samples_gpu_trajectory>`
Refining which base class??

* `mdsim::gpu::sample::trajectory`
* `mdsim::host::sample::trajectory`
Refining which base class??

* :doc:`mdsim::host::forces::smooth <impl/mdsim_host_forces_smooth>`
Refining which base class??

Modules in namespace halmd::io
------------------------------

.. glossary::

    :doc:`trajectory::reader <impl/io_trajectory_reader>`
        Refined by `io::trajectory::readers::hdf5`

        Description:

Modules in namespace halmd::utility
-----------------------------------

.. glossary::

    :doc:`utility::gpu::device <impl/utility_gpu_device>`
        Refining which base class??

        Description:

