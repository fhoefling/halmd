[section Installation]

[section Software prerequisites]

These software packages are required for compilation:

* [@http://www.nvidia.com/object/cuda_get.html
   NVIDIA CUDA toolkit] >= 1.1
* [@http://www.cmake.org/
   CMake] >= 2.6.0 with custom CUDA compiler support patch
* [@http://www.boost.org/
   Boost C++ Libraries] >= 1.39.0 with Boost.Log library
* [@http://www.hdfgroup.org/HDF5/
   HDF5 C++ Library] >= 1.6.6
* [@http://www.gnu.org/software/gsl/
   GNU Scientific Library] (GSL)
* [@http://git-scm.com/
   Git] >= 1.5.6.2
* [@http://www.hdfgroup.org/HDF5/
   HDF5 C++ Library] >= 1.6.6
* [@http://www.gnu.org/software/gsl/
   GNU Scientific Library] (GSL)
* [@http://git-scm.com/
   Git] >= 1.5.6.2

To optionally generate documentation in HTML and PDF format:

* [@http://sphinx.pocoo.org/ Sphinx documentation generator] >= 0.6.1
* LaTeX including pdflatex and dvipng
* graphviz

[heading NVIDIA CUDA toolkit]

For Tesla C1060 or GeForce GT200-based cards, *CUDA 2.2 or 2.3 is recommended*.

With CUDA 2.1 we experienced minor performance degradation on a GeForce GTX 280.

HALMD has proven to run reliably over 10‚Å∏ or more integration steps using
CUDA driver version 185.18.36 (with CUDA 2.0 or 2.2 runtime) and 190.42 (with
CUDA 2.3 runtime). Always look for the newest NVIDIA driver version on the
[@http://www.nvidia.com/object/unix.html NVIDIA Linux driver website], as
the CUDA driver accompanying a CUDA toolkit is not updated and may contain
serious bugs, e.g. that cause hanging GPU kernels.

[heading CMake with custom CUDA compiler support patch]

The patched CMake version, which adds native CUDA language support, is
available at

  git://git.colberg.org/gpgpu/cmake-cuda


To obtain the CUDA patch relative to the newestest supported CMake version

  git diff cmake..master

Alternatively, you can use (or self-compile) these Debian packages:

* [@http://colberg.org/debian/pool/main/c/cmake CMakeCUDA packages for Debian squeeze/sid]

* [@http://colberg.org/ubuntu/pool/main/c/cmake CMakeCUDA packages for Ubuntu karmic]

[note This patch adds *native* CUDA source file compilation and linking
support to CMake and is not to be confused nor compatible with the CUDA module
in CMake 2.8.]

[heading Boost C++ Libraries]

In addition, the proposed [@http://boost-log.sourceforge.net/ Boost.Log]
library is needed, which is acquired with
[pre
  svn co http://boost-log.svn.sourceforge.net/svnroot/boost-log/trunk/boost-log
]

To compile the Boost.Log library, copy the directories `boost/log` and
`libs/log` to the respective paths in the Boost source tree and
[@http://www.boost.org/doc/libs/1_41_0/more/getting_started/unix-variants.html#easy-build-and-install compile Boost]
following the standard installation procedure.

Alternatively, you can use (or self-compile) these Debian packages:

* [@http://colberg.org/debian/pool/main/b/boost1.40 Boost.Log packages for Debian squeeze/sid]

* [@http://colberg.org/ubuntu/pool/main/b/boost1.40 Boost.Log packages for Ubuntu karmic]

The packages are installed alongside the Boost 1.40 packages in Debian/Ubuntu.

[endsect]

[section Compilation]

HALMD uses [@http://www.cmake.org/ CMake] to generate its make files, which is
similar to the more commonly used Autotools suite recognisable by the
`configure` script accompanying a software package, but much faster and much
easier to develop with.

With cmake, out-of-tree compilation is preferred, so we generate the compilation
or build tree in a separate directory. This allows one to have multiple builds
of the same software at the same time, for example a release build with
aggressive optimisation and a debug build including debugging symbols. Note that
the build directory may be a subdirectory in the source tree.

[heading Setting up the cmake build tree]

In the cloned HALMD repository, switch to a new build directory
[pre
  mkdir -p build/release && cd build/release
]

If the third-party packages are installed in standard locations, run
[pre
  cmake ../..
]

This will detect all necessary software, and then generate the make files.

Compilation is done using make, which supports parallel builds
[pre
  nice make -j4
]

Individual backends may be compiled selectively
[pre
  nice make -j4 halmd halmd_gpu_neighbour halmd_host
]

Note that due to extensive use of C++ templates, a *single compiler process*
may easily consume *more than 500MB of memory*, so be sure to adjust the
number of parallel builds to the available resources.

[heading Updating the build tree]

After checking out a new git commit, *switch to the build directory* (e.g.
`build/release`) and run
[pre
  cmake .
]

This instructs cmake to regenerate the build tree using the configuration from a
previous cmake run. Then compile with `make` as usual.

[heading Setting build parameters]

Parameters may be passed to cmake as environment variables or cache variables.

Environment variables are prepended to the cmake command:
[pre
  CXXFLAGS="-fPIC -Wall" cmake ../..
]

:doc:`cmake/env_vars`

Cache variables are appended using the -D option:
[pre
  cmake -DCMAKE_BUILD_TYPE=Release ../..
]

:doc:`cmake/cache_vars`

The following example demonstrates how to compile separate, dynamically linked
executables for each backend, which are statically linked to all libraries except the
standard C and C++ libraries.
[pre
  CXXFLAGS="-fPIC -Wall"
  NVCCFLAGS="-Xcompiler -fPIC -Xptxas -v --host-compilation=c" \
  cmake \
      -DCMAKE_BUILD_TYPE=Release \
      -DHALMD_BACKEND_EXECUTABLES=TRUE \
      -DBoost_USE_STATIC_LIBS=TRUE \
      -DHDF5_USE_STATIC_LIBS=TRUE \
      -DGSL_USE_STATIC_LIBS=TRUE \
      ../..
]

The options given here correspond to the default values.

[heading Further cmake configuration]

Compilation flags may be configured via CMake's text mode interface:
[pre
  ccmake .
]

To finish configuration, hit "c" and "g" to apply and recompile with make.
Alternatively, you may use CMake's graphical interface:
[pre
  cmake-gui .
]

The following switch displays the actual commands invoked by make:
[table
  [[CMake variable]             [Value]]
  [[CMAKE_VERBOSE_MAKEFILE]     [ON]]
]

On some 64-bit systems, cmake may accidently use a 32-bit library instead of its
64-bit counterpart, which results in linker errors. With Mandriva Linux, the
following adjustments are required in ccmake:
[table
  [[CMake variable]             [Value]]
  [[GSL_CBLAS_LIBRARY]          [`/usr/lib64/libgslcblas.so.0`]]
  [[GSL_LIBRARY]                [`/usr/lib64/libgsl.so.0`]]
]

An installation prefix may be specified as following:
[table
  [[CMake variable]             [Value]]
  [[CMAKE_INSTALL_PREFIX]       [[~/home/foo/usr]]]
]

The compiled program is then installed into this tree by
[pre
  make install
]

[endsect]

[section Testing]

HALMD includes a preliminary test suite, which may be started in the build tree by ::

  ctest

[endsect]

[endsect]
