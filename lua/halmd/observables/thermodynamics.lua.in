--
-- Copyright © 2010-2013  Felix Höfling
-- Copyright © 2013       Nicolas Höft
-- Copyright © 2010-2012  Peter Colberg
--
-- This file is part of HALMD.
--
-- HALMD is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
--

local log     = require("halmd.io.log")
local module  = require("halmd.utility.module")
local sampler = require("halmd.observables.sampler")
local utility = require("halmd.utility")

-- grab C++ wrappers
local thermodynamics = assert(libhalmd.observables.thermodynamics)

---
-- Thermodynamics
-- ==============
--
-- This module calculates the instantaneous values of thermodynamic state
-- variables for the particles of a given group.
--

---
-- Construct thermodynamics module.
--
-- :param table args: keyword arguments
-- :param args.group: instance of :mod:`halmd.mdsim.particle_groups`
-- :param args.force: instance of :mod:`halmd.mdsim.forces`
-- :param args.box: instance of :class:`halmd.mdsim.box`
--
-- .. method:: nparticle()
--
--    Returns the number of particles :math:`N` selected by ``args.group``.
--
-- .. method:: density()
--
--    Returns the number density :math:`\rho = N / V` using the volume from
--    ``args.box``.
--
-- .. method:: kinetic_energy()
--
--    Returns the mean kinetic energy per particle:
--    :math:`e_{\text{kin}} = \frac{1}{N} \sum_{i=1}^N \frac{1}{2} m_i \vec v_i^2`.
--
-- .. method:: potential_energy()
--
--    Returns the mean potential energy per particle:
--    :math:`e_{\text{pot}} = \frac{1}{N} \sum_{i=1}^N U_{\text{tot}}(\vec r_i)`,
--    where :math:`U_{\text{tot}}` denotes the sum of external and pair
--    potentials.
--
-- .. method:: total_energy()
--
--    Returns the mean total energy per particle:
--    :math:`e_{\text{tot}} = e_{\text{kin}} + e_{\text{pot}}`.
--
-- .. method:: pressure()
--
--    Returns the pressure computed from the virial:
--    :math:`p = \rho (k_B T - \mathcal{V} / d)`.
--
-- .. method:: temperature()
--
--    Returns the instantaneous temperature as given by the kinetic energy:
--    :math:`k_B T = 2 e_{\text{kin}} / d`.
--
-- .. method:: center_of_mass_velocity()
--
--    Returns the centre-of-mass velocity:
--    :math:`\vec v_{\text{cm}} = \sum_{i=1}^N m_i \vec v_i / \sum_{i=1}^N m_i`.
--
-- .. method:: center_of_mass()
--
--    Returns the centre of mass:
--    :math:`\vec r_{\text{cm}} = \sum_{i=1}^N m_i \vec r_i' / \sum_{i=1}^N m_i`,
--    where :math:`\vec r_i'` refers to absolute particle positions, i.e.,
--    extended by their image vectors for periodic boundary conditions.
--
-- .. method:: mean_mass()
--
--    Returns the mean particle mass: :math:`\bar m = \frac{1}{N} \sum_{i=1}^N m_i`.
--
-- .. method:: virial()
--
--    Returns mean virial per particle as computed from the trace of the
--    potential part of the stress tensor:
--
--    .. math::
--
--      \mathcal{V} = \frac{1}{2 N} \sum_{i \neq j} r_{ij} \, U'(r_{ij}) \, .
--
-- .. method:: hypervirial()
--
--    Returns the mean hypervirial per particle, see the book by M. P. Allen
--    and D. J. Tildesley (Clarendon Press, Oxford, 1987) for a definition.
--    This quantity may be used to determine the isochoric compressibility from
--    NVE simulations, which does not work very well in practice. A superior
--    route is to extrapolate the static structure factor to zero wavenumber.
--
--    *This method will be deprecated in the next release.*
--
-- .. method:: stress_tensor()
--
--    Returns the elements of the stress tensor :math:`\Pi_{\alpha\beta}` as a
--    vector. The first :math:`d` (= `dimension`) elements contain the diagonal
--    followed by :math:`d(d-1)/2` off-diagonal elements :math:`\Pi_{xy},
--    \Pi_{xz}, \dots, \Pi_{yz}, \dots`
--    The stress tensor is computed as
--
--    .. math::
--
--      \Pi_{\alpha\beta} = \sum_{i=1}^N \left[
--        m_i v_{i\alpha} v_{i\beta} +
--        \frac{1}{2}\sum_{j \neq i} \frac{r_{ij\alpha} r_{ij\beta}}{r_{ij}} \, U'(r_{ij})
--        \right] \/,
--
--    where :math:`\vec r_{ij} = \vec r_i - \vec r_j` in nearest image convention.
--
-- .. attribute:: dimension
--
--    Space dimension :math:`d` of the simulation box as a number.
--
-- .. attribute:: group
--
--    Instance of :mod:`halmd.mdsim.particle_groups` used to construct the module.
--
-- .. method:: writer(args)
--
--    Write state variables to a file.
--
--    :param table args: keyword arguments
--    :param args.file: instance of file writer
--    :param number args.every: sampling interval
--    :param string table args.location: location within file (optional)
--    :param table args.fields: data fields to be written (optional)
--    :returns: instance of group writer
--
--    The argument ``location`` specifies a path in a structured file format
--    like H5MD given as a table of strings. If omitted it defaults to
--    ``{"observables", group.label}``.
--
--    The table ``fields`` specifies which data fields are written. It may
--    either be passed as an indexed table, e.g. ``{"pressure"}``,
--    or as a dictionary, e.g., ``{p = "pressure"}``; the table
--    form is interpreted as ``{pressure = "pressure", …}``. The keys denote
--    the field names in the file and are appended to ``location``. The values
--    specify the data methods of the ``thermodynamics`` module, i.e., all
--    methods described above except for ``dimension`` and ``group``. The default
--    is ``{"potential_energy", "pressure", "temperature",
--    "center_of_mass_velocity"}``.
--
--    .. method:: disconnect()
--
--       Disconnect thermodynamics writer from observables sampler.
--
local M = module(function(args)
    local group = utility.assert_kwarg(args, "group")
    local force = utility.assert_kwarg(args, "force")
    local box = utility.assert_kwarg(args, "box")

    local particle = assert(group.particle)
    local label = assert(group.label)
    local logger = log.logger({label = ("thermodynamics (%s)"):format(label)})

    -- construct instance
    local self = thermodynamics(particle, force, group, box, logger)

    self.dimension = property(function(self) return box.dimension end)
    self.group = property(function(self) return group end)

    self.writer = function(self, args)
        local file = utility.assert_kwarg(args, "file")
        local every = utility.assert_kwarg(args, "every")
        local location = utility.assert_type(args.location or {"observables", group.label}, "table")
        local fields = utility.assert_type(
            args.fields or {"potential_energy", "pressure", "temperature", "center_of_mass_velocity"}
          , "table")

        local writer = file:writer{location = location, mode = "append"}

        -- register data fields with writer,
        -- the keys of 'field' may either be strings (dictionary) or numbers (table),
        -- in the latter case, the value string is assigned to the group name
        for k,v in pairs(fields) do
            local name = (type(k) == "string") and k or v
            writer:on_write(assert(self[v]), {name})
        end

        -- sequence of signal connections
        local conn = {}
        writer.disconnect = function(self)
            if #conn > 0 then
                for i = 1, #conn do
                    conn[i]:disconnect()
                end
                conn = {}
            else
                error("thermodynamics writer is already disconnected", 2)
            end
        end

        -- connect writer to sampler
        table.insert(conn, assert(sampler:on_sample(writer.write, every, 0)))
        -- FIXME register profilers

        return writer
    end

    return self
end)

--
-- connect runtime accumulators to module profiler
--
function M.profile(self, profiler)
    local label = assert(self.group.label)
    local profile = function(name, desc)
        if self.runtime[name] then
            profiler:on_profile({self, [name] = ("summation of %s of %s particles"):format(desc, label)})
        end
    end
    profile("en_kin"       , "kinetic energy"         )
    profile("v_cm"         , "centre-of-mass velocity")
    profile("r_cm"         , "centre-of-mass"         )
    profile("en_pot"       , "potential energy"       )
    profile("virial"       , "virial"                 )
    profile("hypervirial"  , "hypervirial"            )
    profile("stress_tensor", "stress tensor"          )
end

return M
