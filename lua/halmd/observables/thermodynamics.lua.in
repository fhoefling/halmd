--
-- Copyright © 2010-2012  Peter Colberg and Felix Höfling
--
-- This file is part of HALMD.
--
-- HALMD is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
--

local clock             = require("halmd.mdsim.clock")
local log               = require("halmd.io.log")
local module            = require("halmd.utility.module")
local sampler           = require("halmd.observables.sampler")

-- grab C++ wrappers
local thermodynamics = assert(libhalmd.observables.thermodynamics)

---
-- Thermodynamics
-- ==============
--
-- This module calculates thermodynamic state variables for the particles of
-- an instance of particle or particle group, which includes
--
-- * potential energy
-- * kinetic energy
-- * total energy
-- * center of mass velocity
-- * pressure
-- * temperature
-- * virial
-- * hypervirial
--

---
-- Construct thermodynamics observable.
--
-- :param table args: keyword arguments
-- :param args.particle: instance of :class:`halmd.mdsim.particle`
-- :param args.box: instance of :class:`halmd.mdsim.box`
--
-- .. method:: writer(file, args)
--
--    Write state variables to file.
--
--    :param file: instance of file writer
--    :param table args: keyword arguments
--    :param number args.every: sampling interval
--    :returns: instance of group writer
--
-- .. attribute:: nparticle
--
--    Callable slot that returns number of particles.
--
-- .. attribute:: density
--
--    Callable slot that returns number density.
--
-- .. attribute:: en_kin
--
--    Callable slot that returns kinetic energy.
--
-- .. attribute:: en_pot
--
--    Callable slot that returns potential energy.
--
-- .. attribute:: en_tot
--
--    Callable slot that returns total energy.
--
-- .. attribute:: pressure
--
--    Callable slot that returns virial pressure.
--
-- .. attribute:: temp
--
--    Callable slot that returns temperature.
--
-- .. attribute:: v_cm
--
--    Callable slot that returns center of mass velocity.
--
-- .. attribute:: virial
--
--    Callable slot that returns virial.
--
-- .. attribute:: hypervirial
--
--    Callable slot that returns hypervirial.
--
local M = module(function(args)
    local particle = args.particle
    if not particle then
        error("missing parameter 'particle'", 2)
    end
    local box = args.box
    if not box then
        error("missing parameter 'box'", 2)
    end
    local label = assert(particle.label)
    local logger = log.logger({label = ("thermodynamics (%s)"):format(label)})

    -- construct instance
    local self = thermodynamics(particle, box, clock, logger)

    self.writer = function(self, file, args)
        local writer = file:writer{location = {"observables"}, mode = "append"}
        writer:on_write(self.en_pot     , {"potential_energy"       , label})
        writer:on_write(self.en_kin     , {"kinetic_energy"         , label})
        writer:on_write(self.en_tot     , {"total_energy"           , label})
        writer:on_write(self.v_cm       , {"center_of_mass_velocity", label})
        writer:on_write(self.pressure   , {"pressure"               , label})
        writer:on_write(self.temp       , {"temperature"            , label})
        writer:on_write(self.virial     , {"virial"                 , label})
        writer:on_write(self.hypervirial, {"hypervirial"            , label})

        -- connect writer to sampler
        local every = args.every
        if not every then
            error("missing parameter 'every'", 2)
        end
        sampler:on_sample(writer.write, every)

        -- turn on computation of auxiliary variables _before_ force computation
        -- in each sampling step
        sampler:on_prepare(particle.aux_enable, every)

        return writer
    end

    return self
end)

--
-- connect runtime accumulators to module profiler
--
function M.profile(self, profiler)
    local label = assert(self.group.label)
    local profile = function(name, desc)
        if self.runtime[name] then
            profiler:on_profile({self, [name] = ("summation of %s of %s particles"):format(desc, label)})
        end
    end
    profile("en_kin"     , "kinetic energy"         )
    profile("v_cm"       , "centre-of-mass velocity")
    profile("en_pot"     , "potential energy"       )
    profile("virial"     , "virial"                 )
    profile("hypervirial", "hypervirial"            )
end

return M
