--
-- Copyright © 2010-2012  Peter Colberg and Felix Höfling
--
-- This file is part of HALMD.
--
-- HALMD is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
--

local log               = require("halmd.io.log")
local module            = require("halmd.utility.module")
local mdsim = {
    box                 = require("halmd.mdsim.box")
  , clock               = require("halmd.mdsim.clock")
  , core                = require("halmd.mdsim.core")
}
local observables = {
    sampler             = require("halmd.observables.sampler")
}
local samples = {
    particle_group      = require("halmd.observables.samples.particle_group")
}

-- grab C++ wrappers
local thermodynamics = assert(libhalmd.observables.thermodynamics)

---
-- Thermodynamics
-- ==============
--
-- This module calculates thermodynamic state variables for the particles of
-- an instance of particle or particle group, which includes
--
-- * potential energy
-- * kinetic energy
-- * total energy
-- * center of mass velocity
-- * pressure
-- * temperature
-- * virial
-- * hypervirial
--
local M = module("halmd.observables.thermodynamics")

---
-- Construct thermodynamics observable.
--
-- :param table args: keyword arguments
-- :param args.particle_group: instance, or sequence of instances, of particle or particle_group
-- :param args.force: instance, or sequence of instances, of corresponding force
-- :returns: instance, or sequence of instances, of thermodynamics
--
-- .. method:: writer(file, args)
--
--    Write state variables to file.
--
--    :param file: instance of file writer
--    :param table args: keyword arguments
--    :param number args.every: sampling interval
--    :returns: instance of group writer
--
-- .. attribute:: nparticle
--
--    Callable slot that returns number of particles.
--
-- .. attribute:: density
--
--    Callable slot that returns number density.
--
-- .. attribute:: en_kin
--
--    Callable slot that returns kinetic energy.
--
-- .. attribute:: en_pot
--
--    Callable slot that returns potential energy.
--
-- .. attribute:: en_tot
--
--    Callable slot that returns total energy.
--
-- .. attribute:: pressure
--
--    Callable slot that returns virial pressure.
--
-- .. attribute:: temp
--
--    Callable slot that returns temperature.
--
-- .. attribute:: v_cm
--
--    Callable slot that returns center of mass velocity.
--
-- .. attribute:: virial
--
--    Callable slot that returns virial.
--
-- .. attribute:: hypervirial
--
--    Callable slot that returns hypervirial.
--
function M.__new(args)
    local particle = args.particle
    if not particle then
        error("missing parameter 'particle'", 3)
    end
    local force = args.force
    if not force then
        error("missing parameter 'force'", 3)
    end
    local box = mdsim.box() -- singleton
    local clock = mdsim.clock() -- singleton

    local observable = function(particle, force)
        local group
        if particle.particle then
            group = particle
        else
            group = samples.particle_group({particle = particle})
        end
        local logger
        local label = group.label -- may be nil
        if label then
            logger = log.logger({label = ("thermodynamics (%s)"):format(label)})
        else
            logger = log.logger({label = "thermodynamics"})
        end

        -- FIXME drop dependency on force module
        local observable = thermodynamics(group, box, clock, force, logger)

        observable.group = property(function(self)
            return group
        end)

        observable.writer = function(self, file, args)
            local writer = file:writer{location = {"observables"}, mode = "append"}
            local label = self.group.label -- may be nil
            writer:on_write(self.en_pot     , {"potential_energy"       , label})
            writer:on_write(self.en_kin     , {"kinetic_energy"         , label})
            writer:on_write(self.en_tot     , {"total_energy"           , label})
            writer:on_write(self.v_cm       , {"center_of_mass_velocity", label})
            writer:on_write(self.pressure   , {"pressure"               , label})
            writer:on_write(self.temp       , {"temperature"            , label})
            writer:on_write(self.virial     , {"virial"                 , label})
            writer:on_write(self.hypervirial, {"hypervirial"            , label})

            -- connect writer to sampler
            local every = args.every
            if not every then
                error("missing parameter 'every'", 2)
            end
            local sampler = observables.sampler() -- singleton
            sampler:on_sample{writer.write, every, tracker = self}

            -- turn on computation of auxiliary variables _before_ force computation
            -- in each sampling step
            -- FIXME move from force to particle
            sampler:on_prepare{force.aux_enable, every, tracker = observable}

            return writer
        end

        return observable
    end

    if type(particle) == "table" then
        local observables = {}
        for i = 1, #particle do
            table.insert(observables, observable(particle[i], force[i]))
        end
        return observables
    else
        return observable(particle, force)
    end
end

--
-- connect runtime accumulators to module profiler
--
function M.profile(self, profiler)
    local label = assert(self.group.label)
    local profile = function(name, desc)
        if self.runtime[name] then
            profiler:on_profile({self, [name] = ("summation of %s of %s particles"):format(desc, label)})
        end
    end
    profile("en_kin"     , "kinetic energy"         )
    profile("v_cm"       , "centre-of-mass velocity")
    profile("en_pot"     , "potential energy"       )
    profile("virial"     , "virial"                 )
    profile("hypervirial", "hypervirial"            )
end

return M
