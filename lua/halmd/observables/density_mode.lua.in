--
-- Copyright © 2011-2012  Felix Höfling
--
-- This file is part of HALMD.
--
-- HALMD is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
--

local clock             = require("halmd.mdsim.clock")
local log               = require("halmd.io.log")
local module            = require("halmd.utility.module")
local observables = {
    phase_space         = require("halmd.observables.phase_space")
  , utility = {
        wavevector      = require("halmd.observables.utility.wavevector")
    }
}

-- grab C++ wrappers
local density_mode_wrapper = libhalmd.observables.density_mode
local po = libhalmd.po
-- grab standard library
local assert = assert
local ipairs = ipairs
local property = property
local type = type


--
-- construct instance of density_mode module
--
-- @param args              parameter table:
--     args.phase_space     list of phase_space samplers with attached labels
--     args.wavenumbers     explicit list of wavenumbers, specify alternatively:
--     args.max_wavenumber  maximum wavenumber
--     args.decimation      decimation parameter for wavenumber grid
--     args.tolerance       tolerance on wavevector magnitude
--     args.max_count       maximum count of wavevectors per wavenumber
-- @returns list of density_mode instances
--
local M = module(function(args)
    -- dependency injection
    local phase_space = assert(args.phase_space, "missing parameter: phase_space")
    assert(type(phase_space) == "table", "invalid table")
    local logger = log.logger({label = "density_mode"})

    local wavenumbers = args.wavenumbers
    local max_wavenumber = args.max_wavenumber or 12.6 -- default value, approx. 4π
    local decimation = args.decimation or 10 -- default value
    local tolerance = args.tolerance or 0.01 -- default value
    local max_count = args.max_count or 7 -- default value

    -- construct local wavevector module
    local wavevector = assert(observables.utility.wavevector)
    if wavenumbers then
        wavevector = wavevector{
            wavenumber = wavenumbers
          , tolerance = tolerance
          , max_count = max_count
        }
    else -- use maximum_wavenumber
        wavevector = wavevector{
            max_wavenumber = max_wavenumber
          , decimation = decimation
          , tolerance = tolerance
          , max_count = max_count
        }
    end

    -- construct list of density modes
    local observable = {}
    for i, phase_space in ipairs(phase_space) do
        local sample = assert(phase_space.sample)
        density_mode = density_mode_wrapper(sample, wavevector, clock, logger) -- FIXME

        -- acquire phase space before acquiring density modes
        density_mode:on_acquire(phase_space.acquire)

        -- store label as Lua property
        local label = assert(phase_space.label)
        density_mode.label = property(function(self) return label end)

        observable[i] = density_mode
    end

    return observable
end)

--
-- connect runtime accumulators to module profiler
--
function M.profile(self, profiler)
    for i, density_mode in ipairs(self) do
        local label = assert(density_mode.label)
        profiler:on_profile{density_mode, acquire = "computation of density modes for " .. label .. " particles"}
    end
end

--
-- assemble module options
--
-- @param desc po.options_description
--
function M.options(desc)
    desc:add("wavenumbers", po.float_array():conflicts("max-wavenumber"), "list of wavenumbers")
    desc:add("max-wavenumber", po.float():conflicts("wavenumbers"), "maximum wavenumber of semi-linearly spaced grid")
    desc:add("decimation", po.uint():conflicts("wavenumbers"), "decimation of wavenumber grid")
    desc:add("tolerance", po.float(), "relative tolerance on wavevector magnitude")
    desc:add("max-count", po.uint(), "maximum number of wavevectors per wavenumber shell")
end

return M
