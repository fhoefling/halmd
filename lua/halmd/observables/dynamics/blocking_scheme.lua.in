--
-- Copyright © 2011-2012 Peter Colberg and Felix Höfling
--
-- This file is part of HALMD.
--
-- HALMD is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
--

local clock             = require("halmd.mdsim.clock")
local log               = require("halmd.io.log")
local module            = require("halmd.utility.module")
local profiler          = require("halmd.utility.profiler")
local sampler           = require("halmd.observables.sampler")
local utility           = require("halmd.utility")

---
-- Blocking Scheme
-- ===============
--

-- grab C++ wrappers
local blocking_scheme = assert(libhalmd.observables.dynamics.blocking_scheme)
local blocking_sample = assert(libhalmd.observables.samples.blocking_scheme)
local correlation = assert(libhalmd.observables.dynamics.correlation)

---
-- Construct blocking scheme.
--
-- :param args: keyword arguments
-- :param number args.max_lag: maximum lag time in MD units
-- :param number args.every: sampling interval of lowest coarse-graining level
-- :param number args.size: size of each block, determines coarse-graining factor
-- :param number args.shift: coarse-graining shift between odd and even levels (defaults to :math:`\lfloor\sqrt\text{size}\rfloor`)
-- :param number args.separation: minimal separation of samples for time averages (defaults to :math:`\text{every}\times\text{size}`)
--
-- .. method:: disconnect()
--
--    Disconnect blocking scheme from sampler.
--
-- .. method:: connect()
--
--    Connect blocking scheme to sampler.
--
--    This is the default.
--
-- .. class:: correlation(tcf, writer)
--
--    Compute time correlation function.
--
--    :param tcf: time correlation function
--    :param writer: instance of :class:`halmd.io.writers.h5md`
--
--    .. method:: disconnect()
--
--       Disconnect correlation function from blocking scheme.
--
--    .. method:: connect()
--
--       Connect correlation function to blocking scheme.
--
--       This is the default.
--
local M = module(function(args)
    local max_lag = args.max_lag
    if type(max_lag) ~= "number" then
        error("bad argument 'max_lag'", 2)
    end
    local every = args.every
    if type(every) ~= "number" then
        error("bad argument 'every'", 2)
    end
    local size = args.size
    if type(size) ~= "number" then
        error("bad argument 'size'", 2)
    end
    local shift = args.shift or math.floor(math.sqrt(size))
    if type(shift) ~= "number" then
        error("bad argument 'shift'", 2)
    end
    local separation = args.separation or every * size
    if type(separation) ~= "number" then
        error("bad argument 'separation'", 2)
    end
    local resolution = every * assert(clock.timestep)
    local logger = log.logger({label = "blocking_scheme"})

    -- construct instance
    local self = blocking_scheme(clock, max_lag, resolution, size, shift, separation, logger)

    self.correlation = function(self, tcf, writer)
        if not tcf then
            error("bad argument 'tcf'", 2)
        end
        if not writer then
            error("bad argument 'writer'", 2)
        end
        local acquire = assert(tcf.acquire)
        local correlate = assert(tcf)
        local group = assert(tcf.group)
        local desc = assert(tcf.desc)

        -- construct blocking sample from acquire() function
        local count = assert(self.count)
        local size = assert(self.block_size)
        local sample = blocking_sample(acquire, count, size)

        -- construct correlation function for blocking scheme
        local result = correlation(tcf, sample, logger)

        -- write correlation function results
        local writer = writer:writer({location = group, mode = "truncate"})
        writer:on_write(self.time, {"time"}) -- FIXME hardlink
        writer:on_write(result.mean, {"mean"})
        writer:on_write(result.error, {"error"})
        writer:on_write(result.count, {"count"})

        -- sequence of signal connections
        local conn = {}
        result.disconnect = utility.signal.disconnect(conn, "correlation function")

        -- connect correlation function to blocking scheme and profiler
        table.insert(conn, assert(self:on_sample(sample)))
        table.insert(conn, assert(self:on_correlate(result)))
        table.insert(conn, assert(self:on_append_finalise(writer.write)))
        table.insert(conn, assert(profiler:on_profile(assert(result.runtime).tcf, desc)))

        return result
    end

    -- sequence of signal connections
    local conn = {}
    self.disconnect = utility.signal.disconnect(conn, "blocking scheme")

    -- connect blocking scheme to sampler
    table.insert(conn, assert(sampler:on_sample(self.sample, every, 0)))
    table.insert(conn, assert(sampler:on_finish(self.finalise)))

    return self
end)

return M
