--
-- Copyright © 2011-2013 Felix Höfling
-- Copyright © 2011-2012 Peter Colberg
--
-- This file is part of HALMD.
--
-- HALMD is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
--

local clock             = require("halmd.mdsim.clock")
local log               = require("halmd.io.log")
local module            = require("halmd.utility.module")
local profiler          = require("halmd.utility.profiler")
local sampler           = require("halmd.observables.sampler")
local utility           = require("halmd.utility")

---
-- Blocking Scheme
-- ===============
--

-- grab C++ wrappers
local blocking_scheme = assert(libhalmd.observables.dynamics.blocking_scheme)
local blocking_sample = assert(libhalmd.observables.samples.blocking_scheme)
local correlation = assert(libhalmd.observables.dynamics.correlation)

---
-- Construct blocking scheme.
--
-- :param args: keyword arguments
-- :param number args.max_lag: maximum lag time in MD units
-- :param number args.every: sampling interval of lowest coarse-graining level
-- :param number args.size: size of each block, determines coarse-graining factor
-- :param number args.shift: coarse-graining shift between odd and even levels (defaults to :math:`\lfloor\sqrt\text{size}\rfloor`)
-- :param number args.separation: minimal separation of samples for time averages (defaults to :math:`\text{every}\times\text{size}`)
--
-- .. method:: disconnect()
--
--    Disconnect blocking scheme from sampler.
--
-- .. class:: correlation(tcf, writer)
--
--    Compute time correlation function.
--
--    :param tcf: time correlation function
--    :param file: instance of :class:`halmd.io.writers.h5md`
--    :param location: locatin within file *(optional)*
--    :type args.location: string table
--
--    The argument ``location`` specifies a path in a structured file format
--    like H5MD given as a table of strings. If omitted it is defined by the
--    time correlation function, typically ``{"dynamics", tcf.label,
--    tcf_name}``.
--
--    .. method:: disconnect()
--
--       Disconnect correlation function from blocking scheme.
--
local M = module(function(args)
    local max_lag = utility.assert_type(utility.assert_kwarg(args, "max_lag"), "number")
    local every = utility.assert_type(utility.assert_kwarg(args, "every"), "number")
    local size = utility.assert_type(args.size, "number")
    local shift = utility.assert_type(args.shift or math.floor(math.sqrt(size)), "number")
    local separation = utility.assert_type(args.separation or every * size, "number")
    local resolution = every * assert(clock.timestep)
    local logger = log.logger({label = "blocking_scheme"})

    -- construct instance
    local self = blocking_scheme(clock, max_lag, resolution, size, shift, separation, logger)

    self.correlation = function(self, tcf, file, location)
        if not tcf then
            error("bad argument 'tcf'", 2)
        end
        if not file then
            error("bad argument 'file'", 2)
        end
        local acquire = assert(tcf.acquire)
        local desc = assert(tcf.desc)

        -- emit notification to blocking_scheme logger
        logger:info("register " .. desc)
        -- switch to tcf-specific logger
        local logger = log.logger({label = desc})

        -- construct blocking sample from acquire() function
        local count = assert(self.count)
        local size = assert(self.block_size)
        local sample = blocking_sample(acquire, count, size)

        -- construct correlation function for blocking scheme
        local result = correlation(tcf, sample, logger)

        -- write correlation function results
        assert(tcf.writer)
        local writer = tcf:writer({file = file, location = location})
        writer:on_write(self.time, {"time"}) -- FIXME hardlink
        writer:on_write(result.mean, {"value"})
        writer:on_write(result.error, {"error"})
        writer:on_write(result.count, {"count"})

        -- sequence of signal connections
        local conn = {}
        result.disconnect = utility.signal.disconnect(conn, "correlation function")

        -- connect correlation function to blocking scheme and profiler
        table.insert(conn, assert(self:on_sample(sample)))
        table.insert(conn, assert(self:on_correlate(result)))
        table.insert(conn, assert(self:on_append_finalise(writer.write)))
        table.insert(conn, assert(profiler:on_profile(assert(result.runtime).tcf, desc)))

        return result
    end

    -- sequence of signal connections
    local conn = {}
    self.disconnect = utility.signal.disconnect(conn, "blocking scheme")

    -- connect blocking scheme to sampler
    table.insert(conn, assert(sampler:on_sample(self.sample, every, 0)))
    table.insert(conn, assert(sampler:on_finish(self.finalise)))

    return self
end)

return M
