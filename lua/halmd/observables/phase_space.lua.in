--
-- Copyright © 2010-2012  Peter Colberg and Felix Höfling
--
-- This file is part of HALMD.
--
-- HALMD is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
--

local clock             = require("halmd.mdsim.clock")
local device            = require("halmd.utility.device")
local log               = require("halmd.io.log")
local module            = require("halmd.utility.module")
local profiler          = require("halmd.utility.profiler")
local sampler           = require("halmd.observables.sampler")
local mdsim = {
    particle_group      = require("halmd.mdsim.particle_group")
}

-- grab C++ classes
local phase_space = {
    host = assert(libhalmd.observables.host.phase_space)
}
if libhalmd.observables.gpu then
    phase_space.gpu = assert(libhalmd.observables.gpu.phase_space)
end

---
-- Phase Space
-- ===========
--
-- A phase_space sampler acquires particle coordinates from an instance of
-- particle or particle_group. The sampler can copy particle data from
-- host to host, gpu to host, or gpu to gpu memory. The particles are
-- ordered by tag, which guarantees that a particle has the same array
-- index over the course of the simulation.
--
local M = module("halmd.observables.phase_space")

---
-- Construct phase_space sampler.
--
-- :param table args: keyword arguments
-- :param args.particle: instance, or sequence of instances, of particle or particle_group
-- :param args.box: instance of :class:`halmd.mdsim.box`
-- :returns: instance, or sequence of instances, of phase_space sampler
--
-- .. note::
--
--    The sample will be updated at most *once* per step, so you can reuse
--    the same sampler with multiple observable modules for optimal
--    performance.
--
-- .. method:: acquire(args)
--
--    Returns data slot to acquire phase space sample.
--
--    :param table args: keyword arguments (optional)
--    :param string args.memory: memory location of phase space sample (optional)
--
--    The supported values for ``memory`` are "host" and "gpu". If ``memory``
--    is not specified, the memory location is selected according to the
--    compute device.
--
-- .. method:: position()
--
--    Returns data slot that acquires phase space sample and returns position array.
--
--    :returns: data slot that returns position array in host memory
--
-- .. method:: velocity()
--
--    Returns data slot that acquires phase space sample and returns velocity array.
--
--    :returns: data slot that returns velocity array in host memory
--
-- .. method:: species()
--
--    Returns data slot that acquires phase space sample and returns species array.
--
--    :returns: data slot that returns species array in host memory
--
-- .. method:: connect()
--
--    Connect phase_space sampler to profiler. This is the default.
--
-- .. method:: disconnect()
--
--    Disconnect phase_space sampler from profiler.
--
-- .. attribute:: group
--
--    The particle group used by the sampler.
--    If a particle instance was given, an ``all`` particle_group.
--
-- .. class:: writer(file, args)
--
--    Write trajectory of particle group to file.
--
--    http://nongnu.org/h5md/draft.html#trajectory-group
--
--    :param file: instance of file writer
--    :param table args: keyword arguments (optional)
--    :param number args.every: sampling interval (optional)
--    :param string args.group: name of trajectory group (optional)
--    :returns: instance of group writer
--
--    If ``every`` is not specified, a phase space sample will be written
--    at the start and end of the simulation.
--
--    If ``group`` is omitted, the particle group's label will be used as
--    the name of the trajectory group.
--
--    .. method:: connect()
--
--       Connect phase_space writer to observables sampler. This is the default.
--
--    .. method:: disconnect()
--
--       Disconnect phase_space writer from observables sampler.
--
function M.__new(args)
    local particle = args.particle
    if not particle then
        error("missing parameter 'particle'", 3)
    end
    local box = args.box
    if not box then
        error("missing parameter 'box'", 3)
    end

    local sampler = function(particle)
        local group
        if particle.particle then
            group = particle
        else
            group = mdsim.particle_group({particle = particle})
        end
        local label = assert(group.label)
        local logger = log.logger({label = ("phase_space (%s)"):format(label)})

        local particle = assert(group.particle)
        local samplers = {}

        -- construct phase space sampler to host memory
        samplers.host = phase_space.host(group, particle, box, clock, logger)

        -- if GPU is used, construct phase space sampler to GPU memory
        if device() then
            samplers.gpu = phase_space.gpu(group, particle, box, clock, logger)
        end

        -- construct unified Lua object for host and gpu sampler
        local self = {group = group}

        self.acquire = function(self, args)
            local memory = args and args.memory
            if not memory then
                memory = device() and "gpu" or "host"
            end
            local sampler = samplers[memory]
            if not sampler then
                error(("unsupported phase_space memory type '%s'"):format(memory), 2)
            end
            return assert(sampler.acquire)
        end

        self.position = function(self)
            return assert(samplers.host.position)
        end

        self.velocity = function(self)
            return assert(samplers.host.velocity)
        end

        self.species = function(self)
            return assert(samplers.host.species)
        end

        self.writer = function(self, file, args)
            local name = args.group or assert(self.group.label)
            local writer = file:writer({location = {"trajectory", name}, mode = "append"})

            writer:on_write(self.position(), {"position"})
            writer:on_write(self.velocity(), {"velocity"})
            writer:on_write(self.species(), {"species"})

            local every = args.every

            -- sequence of signal connections
            local conn = {}

            writer.connect = function(self)
                if #conn == 0 then
                    if every and every > 0 then
                        table.insert(conn, sampler:on_sample(self.write, every))
                    else
                        table.insert(conn, sampler:on_start(self.write))
                        table.insert(conn, sampler:on_finish(self.write))
                    end
                else
                    error("phase_space writer is already connected", 2)
                end
            end

            writer.disconnect = function(self)
                if #conn > 0 then
                    for i = 1, #conn do
                        conn[i]:disconnect()
                    end
                    conn = {}
                else
                    error("phase_space writer is already disconnected", 2)
                end
            end

            -- connect writer to sampler
            writer:connect()

            return writer
        end

        -- sequence of signal connections
        local conn = {}

        self.connect = function(self)
            if #conn == 0 then
                for memory, sampler in pairs(samplers) do
                    local label = assert(self.group.label)
                    local desc = ("phase space sample of %s particles on %s"):format(label, memory)
                    local runtime = assert(sampler.runtime)
                    table.insert(conn, profiler:on_profile(runtime.acquire, ("acquisition of %s"):format(desc)))
                    table.insert(conn, profiler:on_profile(runtime.reset, ("reset %s"):format(desc)))
                end
            else
                error("phase_space sampler is already connected", 2)
            end
        end

        self.disconnect = function(self)
            if #conn > 0 then
                for i = 1, #conn do
                    conn[i]:disconnect()
                end
                conn = {}
            else
                error("phase_space sampler is already disconnected", 2)
            end
        end

        -- connect runtime accumulators to module profiler
        self:connect()

        return self
    end

    if type(particle) == "table" and #particle > 0 then
        local samplers = {}
        for i = 1, #particle do
            table.insert(samplers, sampler(particle[i]))
        end
        return samplers
    else
        return sampler(particle)
    end
end

return M
