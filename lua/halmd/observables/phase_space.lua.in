--
-- Copyright © 2010-2012  Peter Colberg and Felix Höfling
--
-- This file is part of HALMD.
--
-- HALMD is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
--

local clock             = require("halmd.mdsim.clock")
local device            = require("halmd.utility.device")
local log               = require("halmd.io.log")
local module            = require("halmd.utility.module")
local profiler          = require("halmd.utility.profiler")
local sampler           = require("halmd.observables.sampler")

-- grab C++ classes
local phase_space = {host = assert(libhalmd.observables.host.phase_space)}
if device.gpu then
    phase_space.gpu = assert(libhalmd.observables.gpu.phase_space)
end

---
-- Phase Space
-- ===========
--
-- A phase_space sampler acquires particle coordinates from an instance of
-- particle or particle_group. The sampler can copy particle data from
-- host to host, gpu to host, or gpu to gpu memory. The particles are
-- ordered by tag, which guarantees that a particle has the same array
-- index over the course of the simulation.
--

---
-- Construct phase_space sampler.
--
-- :param table args: keyword arguments
-- :param args.group: instance of :class:`halmd.mdsim.particle_group`
-- :param args.box: instance of :class:`halmd.mdsim.box`
--
-- .. note::
--
--    The sample will be updated at most *once* per step, so you can reuse
--    the same sampler with multiple observable modules for optimal
--    performance.
--
-- .. method:: acquire(args)
--
--    Returns data slot to acquire phase space sample.
--
--    :param table args: keyword arguments (optional)
--    :param string args.memory: memory location of phase space sample (optional)
--
--    The supported values for ``memory`` are "host" and "gpu". If ``memory``
--    is not specified, the memory location is selected according to the
--    compute device.
--
-- .. method:: position()
--
--    Returns data slot that acquires phase space sample and returns position array.
--
--    :returns: data slot that returns position array in host memory
--
-- .. method:: velocity()
--
--    Returns data slot that acquires phase space sample and returns velocity array.
--
--    :returns: data slot that returns velocity array in host memory
--
-- .. method:: species()
--
--    Returns data slot that acquires phase space sample and returns species array.
--
--    :returns: data slot that returns species array in host memory
--
-- .. method:: mass()
--
--    Returns data slot that acquires phase space sample and returns mass array.
--
--    :returns: data slot that returns mass array in host memory
--
-- .. method:: set(sample)
--
--    Set positions, velocities, species and masses from phase space sample.
--
-- .. method:: connect()
--
--    Connect phase_space sampler to profiler. This is the default.
--
-- .. method:: disconnect()
--
--    Disconnect phase_space sampler from profiler.
--
-- .. attribute:: group
--
--    The particle group used by the sampler.
--
-- .. class:: writer(file, args)
--
--    Write trajectory of particle group to file.
--
--    http://nongnu.org/h5md/draft.html#trajectory-group
--
--    :param file: instance of file writer
--    :param table args: keyword arguments (optional)
--    :param number args.every: sampling interval (optional)
--    :param string args.group: name of trajectory group (optional)
--    :returns: instance of group writer
--
--    If ``every`` is not specified, a phase space sample will be written
--    at the start and end of the simulation.
--
--    If ``group`` is omitted, the particle group's label will be used as
--    the name of the trajectory group.
--
--    .. method:: connect()
--
--       Connect phase_space writer to observables sampler. This is the default.
--
--    .. method:: disconnect()
--
--       Disconnect phase_space writer from observables sampler.
--
local M = module(function(args)
    local group = args.group
    if not group then
        error("missing parameter 'group'", 2)
    end
    local box = args.box
    if not box then
        error("missing parameter 'box'", 2)
    end
    local particle = assert(group.particle)
    local label = assert(group.label)
    local logger = log.logger({label = ("phase_space (%s)"):format(label)})

    -- construct phase space samplers
    local samplers = {}
    for memory, phase_space in pairs(phase_space) do
        samplers[memory] = phase_space(particle, group, box, clock, logger)
    end

    -- construct unified Lua object for host and gpu sampler
    local self = {group = group}

    self.acquire = function(self, args)
        local memory = args and args.memory
        if not memory then
            memory = device.gpu and "gpu" or "host"
        end
        local sampler = samplers[memory]
        if not sampler then
            error(("unsupported phase_space memory type '%s'"):format(memory), 2)
        end
        return assert(sampler.acquire)
    end

    self.position = function(self)
        return assert(samplers.host.position)
    end

    self.velocity = function(self)
        return assert(samplers.host.velocity)
    end

    self.species = function(self)
        return assert(samplers.host.species)
    end

    self.mass = function(self)
        return assert(samplers.host.mass)
    end

    self.writer = function(self, file, args)
        local name = args.group or assert(self.group.label)
        local writer = file:writer({location = {"trajectory", name}, mode = "append"})

        writer:on_write(self.position(), {"position"})
        writer:on_write(self.velocity(), {"velocity"})
        writer:on_write(self.species(), {"species"})
        writer:on_write(self.mass(), {"mass"})

        local every = args.every

        -- sequence of signal connections
        local conn = {}

        writer.connect = function(self)
            if #conn == 0 then
                if every and every > 0 then
                    table.insert(conn, sampler.on_sample(self.write, every))
                else
                    table.insert(conn, sampler.on_start(self.write))
                    table.insert(conn, sampler.on_finish(self.write))
                end
            else
                error("phase_space writer is already connected", 2)
            end
        end

        writer.disconnect = function(self)
            if #conn > 0 then
                for i = 1, #conn do
                    conn[i]:disconnect()
                end
                conn = {}
            else
                error("phase_space writer is already disconnected", 2)
            end
        end

        -- connect writer to sampler
        writer:connect()

        return writer
    end

    self.set = function(self, ...)
        logger:info(("setting particles from phase space sample"):format(label))
        samplers.host:set(...)
    end

    -- sequence of signal connections
    local conn = {}

    self.connect = function(self)
        if #conn == 0 then
            for memory, sampler in pairs(samplers) do
                local label = assert(self.group.label)
                local desc = ("phase space sample of %s particles on %s"):format(label, memory)
                local runtime = assert(sampler.runtime)
                table.insert(conn, profiler.on_profile(runtime.acquire, ("acquisition of %s"):format(desc)))
                table.insert(conn, profiler.on_profile(runtime.reset, ("reset %s"):format(desc)))
            end
        else
            error("phase_space sampler is already connected", 2)
        end
    end

    self.disconnect = function(self)
        if #conn > 0 then
            for i = 1, #conn do
                conn[i]:disconnect()
            end
            conn = {}
        else
            error("phase_space sampler is already disconnected", 2)
        end
    end

    -- connect runtime accumulators to module profiler
    self:connect()

    return self
end)

-- grab C++ classes
local phase_space
if device.gpu then
    phase_space = {
        [2] = assert(libhalmd.observables.host.samples.phase_space_2_float)
      , [3] = assert(libhalmd.observables.host.samples.phase_space_3_float)
    }
else
    phase_space = {
        [2] = assert(libhalmd.observables.host.samples.phase_space_2_double)
      , [3] = assert(libhalmd.observables.host.samples.phase_space_3_double)
    }
end

---
-- .. class:: reader(file, args)
--
--    Construct reader for given trajectory group.
--
--    http://nongnu.org/h5md/draft.html#trajectory-group
--
--    :param file: instance of :class:`halmd.io.readers.h5md`
--    :param table args: keyword arguments
--    :param string args.group: name of trajectory group
--
--    Returns a group reader, and a phase space sample.
--
--    Example::
--
--       local file = halmd.io.readers.h5md({path = "kob_andersen.h5"})
--       local reader, sample = halmd.observables.phase_space.reader(file, {group = "all"})
--       reader:read_at_step(0)
--       local nparticle = assert(sample.size)
--       local dimension = assert(sample.dimension)
--
--    The returned group reader has these methods.
--
--       .. method:: read_at_step(step)
--
--          Read sample at given step.
--
--          If ``step`` is negative, seek backward from last (``-1``) sample.
--
--       .. method:: read_at_time(time)
--
--          Read sample at given time in MD units.
--
--          If ``time`` is negative, seek backward from last (``-0``) sample.
--
--    The returned phase space sample has these attributes.
--
--       .. attribute:: nparticle
--
--          Returns number of particles.
--
--       .. attribute:: nspecies
--
--          Returns number of species.
--
--          .. note::
--
--             This attribute is determined from the maximum element of the species array.
--
--       .. attribute:: dimension
--
--          Returns dimension of positional coordinates.
--

function M.reader(file, args)
    if not file then
        error("bad argument 'file'", 2)
    end
    local group = args and args.group
    if type(group) ~= "string" then
        error("bad argument 'group'", 2)
    end
    local self = file:reader({location = {"trajectory", group}, mode = "append"})
    local dataset = self.group:open_group("position"):open_dataset("value")
    local shape = assert(dataset.shape)
    local nparticle = assert(shape[2])
    local dimension = assert(shape[3])
    local phase_space = assert(phase_space[dimension])
    if not phase_space then
        error(("unsupported positional dimension: %d"):format(dimension), 2)
    end
    local sample = phase_space(nparticle)
    local names = {"position", "velocity", "species", "mass"}
    for i = 1, #names do
        local name = names[i]
        local array, array_to_sample = sample[name](sample)
        self:on_read(array, {name})
        self:on_append_read(array_to_sample)
    end
    return self, sample
end

return M
