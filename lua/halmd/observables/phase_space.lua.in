--
-- Copyright © 2010-2012  Peter Colberg and Felix Höfling
--
-- This file is part of HALMD.
--
-- HALMD is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
--

local device            = require("halmd.utility.device")
local log               = require("halmd.io.log")
local module            = require("halmd.utility.module")
local mdsim = {
    box                 = require("halmd.mdsim.box")
  , clock               = require("halmd.mdsim.clock")
}
local observables = {
    sampler             = require("halmd.observables.sampler"),
}
local samples = {
    phase_space         = require("halmd.observables.samples.phase_space")
  , particle_group      = require("halmd.observables.samples.particle_group")
}

-- grab C++ wrappers
local phase_space_wrapper = assert(libhalmd.observables.phase_space)
local property = property
-- grab standard library
local assert = assert
local ipairs = ipairs
local type = type

---
-- Phase Space
-- ===========
--
-- A phase_space sampler acquires particle coordinates from an instance of
-- particle or particle_group. The sampler can copy particle data from
-- host to host, gpu to host, or gpu to gpu memory. The particles are
-- ordered by tag, which guarantees that a particle has the same array
-- index over the course of the simulation.
--
local M = module("halmd.observables.phase_space")

---
-- Construct phase_space sampler.
--
-- :param table args: keyword arguments
-- :param args.particle: instance, or sequence of instances, of particle or particle_group
-- :param string args.memory: memory location of phase_space sample (optional)
-- :returns: instance, or sequence of instances, of phase_space sampler
--
-- The supported values for ``memory`` are "host" and "gpu". If ``memory``
-- is not specified, the memory location is selected according to the
-- compute device.
--
-- .. note::
--
--    The sample will be updated at most *once* per step, so you can reuse
--    the same sampler with multiple observable modules for optimal
--    performance.
--
--
-- .. method:: writer(file, args)
--
--    Write trajectory of particle group to file.
--
--    http://nongnu.org/h5md/draft.html#trajectory-group
--
--    :param file: instance of file writer
--    :param table args: keyword arguments (optional)
--    :param number args.every: sampling interval (optional)
--    :param string args.group: name of trajectory group (optional)
--    :returns: instance of group writer
--
--    If ``every`` is not specified, a phase space sample will be written
--    at the start and end of the simulation.
--
--    If ``group`` is omitted, the particle group's label will be used as
--    the name of the trajectory group.
--
--
-- .. attribute:: group
--
--    The particle group used by the sampler.
--    If a particle instance was given, an ``all`` particle_group.
--
-- .. attribute:: sample
--
--    The phase_space sample used by the sampler.
--
-- .. attribute:: acquire
--
--    Callable slot to acquire phase space sample.
--
function M.__new(args)
    local particle = args.particle
    if not particle then
        error("missing parameter 'particle'", 3)
    end
    local memory = args.memory
    if not memory then
        memory = device() and "gpu" or "host"
    end
    local box = mdsim.box() -- singleton
    local clock = mdsim.clock() -- singleton

    local sampler = function(particle)
        local group
        if particle.particle then
            group = particle
        else
            group = samples.particle_group({particle = particle})
        end
        local label = assert(group.label)
        local logger = log.logger({label = ("phase_space (%s)"):format(label)})
        local sample = samples.phase_space({particle = group, memory = memory})
        local sampler = phase_space_wrapper(sample, group, box, clock, logger)

        sampler.sample = property(function(self)
            return sample
        end)
        sampler.group = property(function(self)
            return group
        end)

        sampler.writer = function(self, file, args)
            local name = args.group or assert(self.group.label)
            local writer = file:writer({location = {"trajectory", name}, mode = "append"})
            writer:on_prepend_write(self.acquire)

            local sample = assert(self.sample)
            writer:on_write(sample.position, {"position"})
            writer:on_write(sample.velocity, {"velocity"})
            writer:on_write(sample.types, {"species"})

            local every = args.every
            local sampler = observables.sampler() -- singleton
            if every and every > 0 then
                sampler:on_sample{writer.write, every, tracker = writer}
            else
                sampler:on_start{writer.write, tracker = writer}
                sampler:on_finish{writer.write, tracker = writer}
            end

            return writer
        end

        return sampler
    end

    if type(particle) == "table" then
        local samplers = {}
        for i = 1, #particle do
            table.insert(samplers, sampler(particle[i]))
        end
        return samplers
    else
        return sampler(particle)
    end
end

--
-- connect runtime accumulators to module profiler
--
function M.profile(self, profiler)
    local label = assert(self.group.label)
    local memory = assert(self.sample.memory)
    local desc = ("phase space sample of %s particles on %s"):format(label, memory)
    profiler:on_profile({self, acquire = ("acquisition of %s"):format(desc)})
    profiler:on_profile({self, reset = ("reset %s"):format(desc)})
end

return M
