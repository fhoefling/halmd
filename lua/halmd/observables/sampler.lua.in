--
-- Copyright Â© 2010-2012 Peter Colberg
--
-- This file is part of HALMD.
--
-- HALMD is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
--

local clock             = require("halmd.mdsim.clock")
local core              = require("halmd.mdsim.core")
local posix_signal      = require("halmd.utility.posix_signal")
local profiler          = require("halmd.utility.profiler")
local timer_service     = require("halmd.utility.timer_service")

-- grab C++ wrappers
local sampler = assert(libhalmd.sampler)

---
-- Sampler
-- =======
--
-- The sampler concerts the sampling of observables.
--
-- Example::
--
--    local sampler = require("halmd.observables.sampler")
--    sampler:setup()
--    sampler:run(1000)
--
-- .. method:: setup(self)
--
--    Setup simulation domain.
--
--    This method invokes :meth:`halmd.mdsim.core.setup`.
--
-- .. method:: run(self, steps)
--
--    Run simulation for given number of steps.
--
--    This method invokes :meth:`halmd.mdsim.core.mdstep`.
--
-- .. method:: on_start(self, slot)
--
--    Connect slot to signal.
--
--    :returns: signal connection
--
-- .. method:: on_finish(self, slot)
--
--    Connect slot to signal.
--
--    :returns: signal connection
--
-- .. method:: on_prepare(self, slot, interval)
--
--    Connect slot to signal.
--
--    :returns: signal connection
--
-- .. method:: on_sample(self, slot, interval)
--
--    Connect slot to signal.
--
--    :returns: signal connection
--

-- construct singleton instance
local self = sampler(clock, core)

-- process timer service every step
self:on_sample(timer_service.process, 1)

-- poll for blocked POSIX signals every step
self:on_sample(posix_signal.poll, 1)

-- gracefully abort simulation on SIGTERM or SIGINT
local abort = sampler.abort(clock)
posix_signal:on_term(abort)
posix_signal:on_int(abort)

-- connect runtime accumulators to module profiler
local runtime = assert(self.runtime)
profiler:on_profile(runtime.total, "total simulation runtime")
profiler:on_profile(runtime.start, "start-up of simulation")
profiler:on_profile(runtime.prepare, "preparation for integration step")
profiler:on_profile(runtime.sample, "evaluation of observables")
profiler:on_profile(runtime.finish, "finishing simulation")

return self
