--
-- Copyright Â© 2010-2012 Peter Colberg
--
-- This file is part of HALMD.
--
-- HALMD is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
--

local module            = require("halmd.utility.module")
local mdsim = {
    clock               = require("halmd.mdsim.clock")
  , core                = require("halmd.mdsim.core")
}
local utility = {
    posix_signal        = require("halmd.utility.posix_signal")
  , profiler            = require("halmd.utility.profiler")
  , timer_service       = require("halmd.utility.timer_service")
}

---
-- Sampler
-- =======
--
local M = module.singleton("halmd.observables.sampler")

-- grab C++ wrappers
local sampler = assert(libhalmd.sampler)

---
-- Construct sampler.
--
-- Returns singleton instance of sampler.
--
-- .. method:: setup()
--
--    Setup simulation domain.
--
--    This method invokes :meth:`halmd.mdsim.core.setup`.
--
-- .. method:: run(steps)
--
--    Run simulation for given number of steps.
--
--    This method invokes :meth:`halmd.mdsim.core.mdstep`.
--
-- .. method:: on_start(slot)
--
--    Connect slot to signal.
--
--    :returns: signal connection
--
-- .. method:: on_finish(slot)
--
--    Connect slot to signal.
--
--    :returns: signal connection
--
-- .. method:: on_prepare(slot, interval)
--
--    Connect slot to signal.
--
--    :returns: signal connection
--
-- .. method:: on_sample(slot, interval)
--
--    Connect slot to signal.
--
--    :returns: signal connection
--
function M.__new()
    -- construct sampler instance
    local clock = mdsim.clock() -- singleton
    local core = mdsim.core() -- singleton
    local self = sampler(clock, core)

    -- process timer service every step
    local timer_service = utility.timer_service() -- singleton
    self:on_sample(timer_service.process, 1)

    -- poll for blocked POSIX signals every step
    local posix_signal = utility.posix_signal() -- singleton
    self:on_sample(posix_signal.poll, 1)

    -- gracefully abort simulation on SIGTERM or SIGINT
    local abort = sampler.abort(mdsim.clock())
    posix_signal:on_term(abort)
    posix_signal:on_int(abort)

    -- connect runtime accumulators to module profiler
    local profiler = utility.profiler() -- singleton
    local runtime = assert(self.runtime)
    profiler:on_profile(runtime.total, "total simulation runtime")
    profiler:on_profile(runtime.start, "start-up of simulation")
    profiler:on_profile(runtime.prepare, "preparation for integration step")
    profiler:on_profile(runtime.sample, "evaluation of observables")
    profiler:on_profile(runtime.finish, "finishing simulation")

    return self
end

return M
