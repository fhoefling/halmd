--
-- Copyright Â© 2019 Roya Ebrahimi Viand
--
-- This file is part of HALMD.
--
-- HALMD is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Lesser General Public License as
-- published by the Free Software Foundation, either version 3 of
-- the License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Lesser General Public License for more details.
--
-- You should have received a copy of the GNU Lesser General
-- Public License along with this program.  If not, see
-- <http://www.gnu.org/licenses/>.

local utility = require("halmd.utility")
local device  = require("halmd.utility.device")
local module  = require("halmd.utility.module")

---
-- Sphere
-- ======
--
-- Selects particles that are inside or outside a specified sphere domain of the system.
--

local sphere = {
    single = assert(libhalmd.mdsim.geometries.sphere_float)
  , double = assert(libhalmd.mdsim.geometries.sphere_double)
}

---
-- Construct sphere geometry instance.
--
-- :param table args: keyword arguments
-- :param table args.center: sphere center 
-- :param number args.radius: sphere radius
-- :param string args.precision: floating point number precision *(optional)*
--
--
--    The supported values for ``precision`` are "single" and "double". If ``precision``
--    is not specified, the precision is selected according to the
--    compute device.
--
-- .. note::
--
--    This module does not perform a validation of the meaningfulness of the domain,
--    i.e. it does not test whether the geometry is placed outside the simulation
--    domain.
--
local M = module(function(args)
    utility.assert_type(args, "table")
    local center = utility.assert_type(utility.assert_kwarg(args, "center"), "table")
    local radius = utility.assert_type(utility.assert_kwarg(args, "radius"), "number")
    local precision = args.precision or (device.gpu and "single" or "double")

    if not sphere[precision] then
         error("Unsupported precision", 2)
    end

    -- construct instance
    local self = sphere[precision](center, radius)

    return self
end)

return M

