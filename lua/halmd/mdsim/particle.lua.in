--
-- Copyright Â© 2010-2012 Peter Colberg
--
-- This file is part of HALMD.
--
-- HALMD is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Lesser General Public License as
-- published by the Free Software Foundation, either version 3 of
-- the License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Lesser General Public License for more details.
--
-- You should have received a copy of the GNU Lesser General
-- Public License along with this program.  If not, see
-- <http://www.gnu.org/licenses/>.
--

local core              = require("halmd.mdsim.core")
local utility           = require("halmd.utility")
local device            = require("halmd.utility.device")
local module            = require("halmd.utility.module")
local profiler          = require("halmd.utility.profiler")
local utility           = require("halmd.utility")

---
-- Particle
-- ========
--

-- grab C++ wrappers
local particle = {}
particle.host = {
    ["double"] = {
        [2] = assert(libhalmd.mdsim.host.particle_2)
      , [3] = assert(libhalmd.mdsim.host.particle_3)
    }
}

if device.gpu then
    particle.gpu = {
        ["single"] = {
            [2] = assert(libhalmd.mdsim.gpu.particle_float_2)
          , [3] = assert(libhalmd.mdsim.gpu.particle_float_3)
        },
        ["double"] = {
            [2] = assert(libhalmd.mdsim.gpu.particle_dsfloat_2)
          , [3] = assert(libhalmd.mdsim.gpu.particle_dsfloat_3)
        }
    }
end

---
-- Construct particle instance.
--
-- :param table args: keyword arguments
-- :param number args.dimension: dimension of space
-- :param number args.particles: number of particles
-- :param number args.species: number of species (*default:* 1)
-- :param string args.precision: floating point precision *(optional)*
-- :param string args.memory: device where the particle information is stored *(optional)*
-- :param string args.label: instance label (*default:* ``all``)
--
-- The supported values for ``memory`` are "host" and "gpu". If ``memory`` is
-- not specified, the memory location is selected according to the compute
-- device.
--
-- .. attribute:: nparticle
--
--    Number of particles.
--
-- .. attribute:: nspecies
--
--    Number of particle species.
--
-- .. attribute:: label
--
--    Instance label.
--
-- .. attribute:: memory
--
--    Device where the particle memory resides.
--
-- .. attribute:: data
--
--    Pseudo-table providing access to the particle data::
--
--        table = particle.data["position"]
--        particle.data["position"] = table
--
--    Per default a particle instance contains the following named data arrays:
--    "position", "image", "velocity", "id", "reverse_id", "species", "mass",
--    "force", "en_pot", "stress_pot"
--
-- .. warning::
--
--    Accessing particle data using this table is equivalent
--    to calling :meth:`get` resp. :meth:`set` and involves
--    a full copy of the data to a lua table.
--
-- .. warning::
--
--    During simulation, particle arrays are reordered in memory according
--    to a space-filling curve. To access particles in initial order, use
--    :meth:`get_reverse_id` to retrieve a map from particle IDs to current
--    particle indices in memory.
--
-- .. method:: get(name)
--
--    Returns particle data identified by the name of the particle array.
--
--    :param string name: identifier of the particle array
--
-- .. method:: set(name, data)
--
--    Set particle data identified by the name of the particle array.
--
--    :param string name: identifier of the particle array
--    :param table data: table containing the data
--
-- .. method:: shift_velocity(vector)
--
--    Shift all velocities by ``vector``.
--
-- .. method:: shift_velocity_group(group, vector)
--
--    Shift velocities of group by ``vector``.
--
-- .. method:: rescale_velocity(scalar)
--
--    Rescale magnitude of all velocities by ``scalar``.
--
-- .. method:: rescale_velocity_group(group, scalar)
--
--    Rescale magnitude of velocities of group by ``scalar``.
--
-- .. method:: shift_rescale_velocity(vector, scalar)
--
--    First shift, then rescale all velocities.
--
-- .. method:: shift_rescale_velocity_group(group, vector, scalar)
--
--    First shift, then rescale velocities of group.
--
-- .. method:: aux_enable()
--
--    Enable the computation of auxliliary variables in the next on_force()
--    step. These are: ``stress_pot`` and ``potential_energy`` and derived
--    properties (such as the internal energy or the virial). The auxiliary
--    variables should be activated like this::
--
--      sampler:on_prepare(function() particle:aux_enable() end, every, start)
--
-- .. method:: on_prepend_force(slot)
--
--    Connect nullary slot to signal.
--
--    :returns: signal connection
--
-- .. method:: on_force(slot)
--
--    Connect nullary slot to signal.
--
--    :returns: signal connection
--
-- .. method:: on_append_force(slot)
--
--    Connect nullary slot to signal.
--
--    :returns: signal connection
--
-- .. method:: __eq(other)
--
--    :param other: instance of :class:`halmd.mdsim.particle`
--
--    Implements the equality operator ``a = b`` and returns true if the other
--    ``particle`` instance is the same as this one.
--
local M = module(function(args)
    utility.assert_type(args, "table")
    local dimension = utility.assert_type(utility.assert_kwarg(args, "dimension"), "number")
    local nparticle = utility.assert_type(utility.assert_kwarg(args, "particles"), "number")
    local nspecies = utility.assert_type(args.species or 1, "number")
    local label = utility.assert_type(args.label or "all", "string")

    local memory = args and args.memory or (device.gpu and "gpu" or "host")
    if not particle[memory] then
        error(("unsupported particle memory type '%s'"):format(memory), 2)
    end
    local precision = args and args.precision or "double"
    if not particle[memory][precision] then
        error(("unsupported particle float type '%s'"):format(float_type), 2)
    end

    -- select particle class
    local particle = assert(particle[memory][precision][dimension])

    -- construct particle instance
    local self = particle(nparticle, nspecies)

    -- add data field for accessing the particle arrays
    self.data = setmetatable({}, {
        __index = function(table, key)
            return self:get(key)
        end,
        __newindex = function(table, key, value)
            self:set(key, value)
        end
    })

    -- store particle label as Lua property
    self.label = property(function(self)
        return label
    end)

    self.memory = property(function(self)
        return memory
    end)

    self.precision = property(function(self)
        return precision
    end)

    -- sequence of signal connections
    local conn = {}
    self.disconnect = utility.signal.disconnect(conn, "particle module")

    -- connect to profiler
    local runtime = assert(self.runtime)
    table.insert(conn, profiler:on_profile(runtime.rearrange, "rearrange particles by permutation (" .. label .. ")"))

    return self
end)

return M
