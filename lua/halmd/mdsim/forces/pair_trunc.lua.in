--
-- Copyright © 2010-2011  Peter Colberg and Felix Höfling
--
-- This file is part of HALMD.
--
-- HALMD is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
--

local core              = require("halmd.mdsim.core")
local device            = require("halmd.utility.device")
local module            = require("halmd.utility.module")
local mdsim = {
    neighbour           = require("halmd.mdsim.neighbour")
}

-- grab modules
local forces = libhalmd.mdsim.forces
local discontinuous = assert(libhalmd.mdsim.forces.trunc.discontinuous)

-- grab standard library
local property = property
local assert = assert

local M = module("halmd.mdsim.forces.pair_trunc")

--
-- construct truncated pair force module
--
-- @param args.potential potential name
-- @param args.trunc smoothing function (defaults to no smoothing)
--
function M.__new(args)
    local particle1 = assert(args.particle or args.particles[1])
    local particle2 = assert(args.particle or args.particles[2])
    local box = assert(args.box)
    local dimension = assert(box.dimension)
    local potential = assert(args.potential)
    local trunc = args.trunc or discontinuous()
    local neighbour = args.neighbour -- optional

    -- create neighbour lists with cutoff radii of potential
    if not neighbour then
        neighbour = mdsim.neighbour{box = box, particles = {particle1, particle2}, r_cut = potential.r_cut}
    end

    -- construct force module
    local force = assert(forces.pair_trunc)(potential, particle1, particle2, box, neighbour, trunc)

    -- system preparation
    core:on_append_setup(force.compute)
    -- compute forces every step
    core:on_force(force.compute)

    -- store potential Lua object (which contains the C++ object) as a
    -- read-only Lua property, so we may read it in pair_trunc.profile
    -- and retrieve the description of the potential for the log entry
    force.potential = property(function(self)
        return potential
    end)

    return force
end

--
-- connect runtime accumulators to module profiler
--
function M.profile(self, profiler)
    profiler:on_profile{self, compute = "computation of " .. self.potential.module.description() .. " interaction"}
end

--
-- returns module description
--
function M.description()
    return "Truncated pair interaction"
end

return M
