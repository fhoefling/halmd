--
-- Copyright © 2010-2011  Peter Colberg and Felix Höfling
--
-- This file is part of HALMD.
--
-- HALMD is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
--

local device            = require("halmd.utility.device")
local module            = require("halmd.utility.module")
local mdsim = {
    box                 = require("halmd.mdsim.box")
  , core                = require("halmd.mdsim.core")
  , neighbour           = require("halmd.mdsim.neighbour")
}

-- grab modules
local forces = libhalmd.mdsim.forces

-- grab standard library
local property = property
local assert = assert

local M = module("halmd.mdsim.forces.pair_trunc")

--
-- construct truncated pair force module
--
-- @param args.potential potential name
--
function M.__new(args)
    local particle1 = assert(args.particle or args.particles[1])
    local particle2 = assert(args.particle or args.particles[2])
    local potential = assert(args.potential)
    local neighbour = args.neighbour -- optional

    local box = mdsim.box() -- singleton
    local dimension = assert(box.dimension)

    -- create neighbour lists with cutoff radii of potential
    if not neighbour then
        neighbour = mdsim.neighbour{particles = {particle1, particle2}, r_cut = potential.r_cut}
    end

    -- construct force module
    local force = assert(forces.pair_trunc)(potential, particle1, particle2, box, neighbour)

    -- move tracked signal connections from neighbour to force;
    -- on force:disconnect() the core signals connections of
    -- both force and neighbour will be disconnected
    neighbour:move_connections(force)

    local core = mdsim.core()
    -- system preparation
    core:on_append_setup{force.compute, tracker = force}
    -- compute forces every step
    core:on_force{force.compute, tracker = force}

    -- store potential Lua object (which contains the C++ object) as a
    -- read-only Lua property, so we may read it in pair_trunc.profile
    -- and retrieve the description of the potential for the log entry
    force.potential = property(function(self)
        return potential
    end)

    return force
end

--
-- connect runtime accumulators to module profiler
--
function M.profile(self, profiler)
    profiler:on_profile{self, compute = "computation of " .. self.potential.module.description() .. " interaction"}
end

--
-- returns module description
--
function M.description()
    return "Truncated pair interaction"
end

return M
