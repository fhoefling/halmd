--
-- Copyright Â© 2011  Peter Colberg
--
-- This file is part of HALMD.
--
-- HALMD is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
--

-- @module halmd.modules.signals
--
-- This module implements connection tracking for a C++ module that provides
-- signals. When a slot is connected to a signal, a connection object is
-- returned, which allows later disconnection of the slot from the signal.
-- With a raw C++ signal method, a connection of a slot looks like this:
--
--   core:on_prepend_force(neighbour.update)
--
-- If a Lua module is patched with signals.patch, this turns into:
--
--   core:on_prepend_force{neighbour.update, tracker = neighbour}
--
-- i.e. neighbour becomes the tracker of the connection of the slot
-- neighbour.update to the signal on_prepend_force. This allows
-- disconnecting the slot later on, provided that module (in this
-- example core) still exists:
--
--   neighbour:disconnect()
--
-- A tracker may track an arbitrary number of signal connections.
-- Further the tracked connections may be moved to another module:
--
--   neighbour:move_connections(force)
--
-- This allows tracking connections of different modules with a single
-- module, with disconnection of a module along with its dependencies:
--
--   force:disconnect() -- disconnects neighbour.update slot
--

-- module definition
-- @see http://lua-users.org/wiki/ModuleDefinition
-- @see http://lua-users.org/wiki/LuaModuleFunctionCritiqued
local signals = {}

-- keep connections per tracker in a table with weak keys;
-- if the tracker goes out of scope, the tracked connections
-- will be garbage collected
local connections = setmetatable({}, {__mode = "k"})

-- forward declarations of internal module functions
local track
local disconnect
local move_connections

-- append connection to the connection table of tracker
function track(tracker, conn)
    assert(tracker, "missing tracker")
    assert(conn, "missing connection")
    if not connections[tracker] then
        connections[tracker] = {}
        tracker.disconnect = disconnect
        tracker.move_connections = move_connections
    end
    table.insert(connections[tracker], conn)
end

-- disconnect all slots tracked by tracker
function disconnect(tracker)
    assert(tracker, "missing tracker")
    for _, c in pairs(connections[tracker]) do
        c:disconnect()
    end
    connections[tracker] = nil
    tracker.disconnect = nil
    tracker.move_connections = nil
end

-- move connections from tracker to destination tracker
function move_connections(tracker, destination)
    assert(tracker, "missing tracker")
    assert(destination, "missing destination tracker")
    for _, c in pairs(connections[tracker]) do
        track(destination, c)
    end
    connections[tracker] = nil
    tracker.disconnect = nil
    tracker.move_connections = nil
end

-- patch C++ objects with signal connection handlers
--
-- Luabind allows setting and getting arbitrary Lua values in a C++ object.
-- For details see the file "src/object_rep.cpp" in the Luabind source,
-- in particular the function set_instance_value. This function creates
-- a metatable in the object representation upon first setting a value.
--
-- signals.patch captures the original constructor (new) of a Lua module,
-- and overrides it with a function that modifies the constructed C++
-- object: For each signal connection method in an object constructed
-- by that Lua module, the original method is captured and overridden
-- with a Lua function that sets up connection tracking.
--
function signals.patch(module)
    local new = module.new

    module.new = function(args)
        local object = new(args)
        local class = class_info(object)

        for name, method in pairs(class.methods) do
            if name:match("^on_") then
                --
                -- The C++ signal connection method is overridden with a Lua
                -- function that receives a single argument table, with the
                -- C++ method arguments indexed by number and the additional
                -- Lua arguments indexed by string, for example
                --
                --   core:on_prepend_force{neighbour.update, tracker = neighbour}
                --
                -- The Lua argument tracker is a C++ object itself that will track
                -- the connection returned by the C++ signal connection method.
                --
                -- We support multiple return values for the method, e.g. a H5MD
                -- writer may return the connection as first and the HDF5 dataset
                -- as second argument. The return values are captured in a table.
                -- The first argument with the connection is passed to the tracker,
                -- and the remaining arguments are returned to the caller.
                --
                object[name] = function(self, args)
                    assert(type(args) == "table", "missing argument table")
                    -- unpack reads only table values indexed by number
                    local values = {method(self, table.unpack(args))}
                    local conn = table.remove(values, 1)
                    local tracker = args.tracker
                    track(tracker, conn)
                    return table.unpack(values)
                end
            end
        end
        return object
    end
end

-- return local module to calling module
return signals
